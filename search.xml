<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于大模型应用的一些思考</title>
      <link href="/2024/03/29/%E5%9F%BA%E4%BA%8E%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
      <url>/2024/03/29/%E5%9F%BA%E4%BA%8E%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h4 id="前言简介"><a href="#前言简介" class="headerlink" title="前言简介"></a>前言简介</h4><p>到目前为止（2024年3月29日），从媒体的消息来看，关注的焦点还是集中于大模型本身。比如，Anthropic推出来的Claude 3，谷歌推出Gemini，Meta推出免费的Llama 2等等大模型。也就是大模型本身激战正酣，巨头争相竞技。至于为什么，我觉得就是大模型几乎肉眼可见的潜力（在继VR、MR、区块链、元宇宙等概念之后，终于出现一个够得着的科技概念）。<br>我们来看一张大模型应用的架构图：</p><p><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/think_in_llm/llm-reference-arch.png" alt="大模型应用架构图"></p><p>从上图，我们不难看出，大模型的提供的能力是灵魂所在，是核心的驱动力。从AI应用产业角度来说，大模型是绝对的上游，而且这种联系，将前所未有的紧密，也就是离了大模型，就没有大模型应用（好像是句废话），这就是巨头争相竞技的原因。</p><p>但现在，让我们先把这种神仙打架的事情先放一放，集中精力大模型应用，思考如何释放大模型的洪荒之力。</p><p><strong>（未完待续）</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Postgresql和Sqlserver开启两阶段事务</title>
      <link href="/2023/11/29/Postgresql%E5%92%8CSqlserver%E5%BC%80%E5%90%AF%E4%B8%A4%E9%98%B6%E6%AE%B5%E4%BA%8B%E5%8A%A1/"/>
      <url>/2023/11/29/Postgresql%E5%92%8CSqlserver%E5%BC%80%E5%90%AF%E4%B8%A4%E9%98%B6%E6%AE%B5%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="postgresql配置"><a href="#postgresql配置" class="headerlink" title="postgresql配置"></a>postgresql配置</h3><p>postgresql通过启用max_prepared_transactions来支持两阶段事务</p><ol><li><p><strong>找到postgresql.conf文件</strong><br>  不同环境的postgresql数据库目录结构不尽相同，但关键是找到postgresql.conf，以下是常用的方式。</p><ul><li>使用命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find / -name postgresql.conf</span><br></pre></td></tr></table></figure></li><li>直接访问目录（找到data目录）<br>常见的目录：postgresql&#x2F;{版本号}&#x2F;data，如:postgresql&#x2F;16&#x2F;data，表示postgresql16的data目录</li></ul></li><li><p><strong>启用参数max_prepared_transactions</strong><br>  在上一步找到的postgresql.conf文件找到max_prepared_transactions，并修改为max_prepared_transactions&#x3D;100。<br><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/prepared_transactions/preparedtransactions/pgsql1.png" alt="prepared_transactions配置"></p><ul><li>上述配置表示最多允许100个预备事务，具体数量请根据实际情况酌情更改</li><li>如果没有max_prepared_transactions参数，可自行添加</li></ul></li><li><p><strong>重启postgresql数据库</strong></p></li></ol><h3 id="sqlserver配置"><a href="#sqlserver配置" class="headerlink" title="sqlserver配置"></a>sqlserver配置</h3><p>sqlserver的两个阶段事务启用较为繁琐，需要在相关的服务器确保msdtc服务的开启，包括<strong>未部署数据库的iis宿主服务器或其他客户端服务器</strong></p><ol><li><p><strong>启动msdtc服务</strong><br>  <img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/prepared_transactions/preparedtransactions/sqlserver1.png" alt="msdtc服务"></p></li><li><p><strong>配置本地DTC</strong><br>  控制面板-&gt;管理工具-&gt;组件服务-&gt;计算机-&gt;我的电脑-&gt;本地DTC，使用下列配置<br>  <img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/prepared_transactions/preparedtransactions/sqlserver2.png" alt="本地dtc配置1"><br>  <img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/prepared_transactions/preparedtransactions/sqlserver3.png" alt="本地dtc配置2"></p></li><li><p><strong>数据库实例的msdts配置(可选配置，实测中未开启也能成功)</strong><br>  如图所示，sqlserver实例-&gt;属性-&gt;连接，勾选：<strong>需要将分布式事务用于服务器到服务器的通信(E)</strong><br>  <img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/prepared_transactions/preparedtransactions/sqlserver4.png" alt="sqlserver实例配置"></p></li><li><p><strong>注意事项</strong></p><ul><li>一般情况下，修改配置可以立即生效，未生效则应尝试重启数据库或服务器</li><li>需要确保msdtc端口可用，下面是建议的windows防火墙的配置<br> <img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/prepared_transactions/preparedtransactions/sqlserver5.png" alt="windows防火墙配置"></li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Postgresql数据库中分区表和表继承的区别</title>
      <link href="/2023/11/29/Postgresql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%88%86%E5%8C%BA%E8%A1%A8%E5%92%8C%E8%A1%A8%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/11/29/Postgresql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%88%86%E5%8C%BA%E8%A1%A8%E5%92%8C%E8%A1%A8%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h4><p>在Postgresql中，经常使用分区表和表继承来处理分表的的场景，而其对应的数据组织和管理策略则不尽相同，本文主要对比分区表和表继承在分表场景的异同</p><h4 id="具体对比"><a href="#具体对比" class="headerlink" title="具体对比"></a>具体对比</h4><table><thead><tr><th>对比类型</th><th>分区表</th><th>表继承</th></tr></thead><tbody><tr><td>数据操作-写入</td><td>根据分区规则自动路由</td><td>需要创建insert触发器，依赖触发器来完成数据路由</td></tr><tr><td>数据操作-更新</td><td>只需操作主表</td><td>只需操作主表</td></tr><tr><td>数据操作-删除</td><td>只需操作主表</td><td>只需操作主表</td></tr><tr><td>查询对象</td><td>针对主表查询即可</td><td>针对主表查询即可</td></tr><tr><td>查询性能</td><td>分区表有明确的分区条件，在查询的时候仅扫描相关分区，从而提升性能</td><td>不会划分物理分区，所有数据都保存在各个表当中</td></tr><tr><td>表结构管理-新建子表</td><td>手动创建</td><td>手动创建</td></tr><tr><td>表结构管理-主键</td><td>主表的主键默认为全局主键，自动作用于分区表</td><td>需要各自管理主键</td></tr><tr><td>表结构管理-索引</td><td>主表通过建立全局索引（默认），可作用于所有分区表（也可以在分区表上建立局部索引）</td><td>需要各自管理索引</td></tr><tr><td>表结构管理-字段</td><td>主表和子表字段必须完全一致</td><td>子表和主表的字段可以不一致</td></tr><tr><td>表结构管理-唯一约束</td><td>唯一约束（如主键）需包含分区键</td><td>无要求（未确认）</td></tr><tr><td>表结构管理-分区规则</td><td><li>范围分区<li>列表分区<li>哈希分区<li>自定义分区</td><td>无明确的分区规则，需自行处理</td></tr><tr><td>数据管理-备份</td><td>可单独备份分区表</td><td>可单独备份子表</td></tr><tr><td>数据管理-删除子表</td><td>drop对应分区表即可，可以非常快的移除百万级的数据</td><td>通过解除子表的关系可达到移除子表的效果</td></tr></tbody></table><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>从上述的对比中，我们不难发现，分区表适合进行水平分表。而表继承的设计较为灵活，更适合应对模型当中的集成结构，适合垂直分表</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows下使用docker进行开发调试环境准备</title>
      <link href="/2023/11/09/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8docker%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"/>
      <url>/2023/11/09/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8docker%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p>现在的软件项目开发调试日趋复杂，经常需要一堆的软件环境才能正常的进行开发调试。比如数据库、redis、mq等等，这些软件安装麻烦还不好管理，平时不用还占着资源。有没有一种办法解决这个问题呢？答案是有的，我们可以借助docker来完成软件环境的准备，本文将在windows10&#x2F;11的环境下演示使用docker进行开发调试环境准备。</p><ul><li><strong>WSL2环境准备</strong><br>本文只推荐使用基于window for linux的docker安装，原因此处不便展开，具体请百度</li></ul><ol><li><p>打开系统虚拟机平台和WSL(适用于Linux的window子系统)。<br>控制面板-&gt;程序-&gt;启用或关闭Windows功能-&gt;向下滑 勾选以下两项功能。<br><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/winfeatures.png" alt="winfeatures" title="windows功能"></p></li><li><p>下载支持Linux的内核wsl2<br>点击<a href="https://docs.microsoft.com/zh-cn/windows/wsl/wsl2-kernel">官网链接</a>，下载最新版本的更新包，双击运行安装即可。这时你的wsl就为wsl2了</p></li><li><p>设置Wsl默认版本<br>打开Powershell，输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set -default -version 2</span><br></pre></td></tr></table></figure><p>如果仅需要安装docker for windows，那对于wsl2的安装就到此为止了，并不需要安装发行版</p></li></ol></br><hr></br><ul><li><strong>Docker for Windows的安装</strong></li></ul><ol><li><p>下载docker for windows<br>点击<a href="https://www.docker.com/products/docker-desktop/">官网链接</a>，选择docker for windows下载安装</p></li><li><p>设置并启动docker<br>2.1 打开设置setting-&gt;General<br><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/dockersetting.png" alt="dockersetting" title="打开Docker设置"><br>2.2 勾选:Use the wsl2 based engine，并点击Apply &amp; restart<br><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/usewsl2.png" alt="usewsl2" title="使用Wsl2引擎"></p></li><li><p>设置国内镜像加速<br>由于各种原因，默认的镜像地址经常出现缓慢和不稳定，为了我们顺利的使用docker，需要设置国内镜像加速。<br>3.1 打开settings-&gt;Docker Engine<br><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/dockerengine.png" alt="dockerengine" title="Docker引擎"><br>3.2 设置registry-mirrors</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;builder&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;gc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;defaultKeepStorage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20GB&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;experimental&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;https://自己生成.mirror.aliyuncs.com&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>国内常用的镜像加速地址：</strong></p><table><thead><tr><th>镜像提供商</th><th>地址url</th></tr></thead><tbody><tr><td>Docker中国区官方镜像</td><td><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></td></tr><tr><td>网易</td><td><a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></td></tr><tr><td>阿里云（需要自己生成）</td><td>登录：cr.console.aliyun.com</td></tr></tbody></table></li></ol></br><hr></br><ul><li><strong>安装启动postresql数据库</strong><blockquote><p>本节内容将完成postgresql的镜像启动，并将涉及docker的一个重要概念：数据卷的运用<br>数据卷的定义：Docker数据卷是一个可以在Docker容器和主机之间共享数据的特殊目录。它允许容器在不影响主机文件系统的情况下访问主机上的文件，并且可以在多个容器之间共享数据。使用数据卷可以方便地将数据持久化保存，并且在容器删除后仍然保留数据。数据卷是Docker中非常方便的功能，可以帮助用户更好地管理和维护容器化应用程序。<br>简略版：你如果不想<strong>数据随着容器的删除而消失</strong>，就必须独立于容器之外的数据卷<br>综上所述：对于启用postgresql容器，使用数据卷挂载是非常必要的</p></blockquote></li></ul><ol><li><p>创建数据卷<br>1.1 使用下面的命令创建名为pgdata的数据卷</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">volume</span><span class="language-bash"> create pgdata</span></span><br></pre></td></tr></table></figure><p>1.2 查看数据卷，输入命令：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">volume</span><span class="language-bash"> list</span></span><br></pre></td></tr></table></figure><p><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/volume-list.png" alt="dockervolumes" title="查看数据卷"></p></li><li><p>获取Docker镜像<br>2.1 查询目标镜像，输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search postgres</span><br></pre></td></tr></table></figure><p><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/searchimages.png" alt="searchimages" title="查询目标镜像"><br>2.2 拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull postgres</span><br></pre></td></tr></table></figure><p><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/docker-images.png" alt="docker-images" title="本地镜像"></p></li><li><p>使用docker run 命令启动容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name postgress --restart always -e TZ=&#x27;Asia/Shanghai&#x27; -e POSTGRES_PASSWORD=&#x27;1234qwer&#x27; -e ALLOW_IP_RANGE=0.0.0.0/0 -v pgdata:/var/lib/postgresql/data -p 55435:5432 -d postgres</span><br></pre></td></tr></table></figure><p>查看已启动容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><strong>命令详解</strong></p><table><thead><tr><th>命令名称</th><th>解释及描述</th></tr></thead><tbody><tr><td>–name</td><td>容器名称</td></tr><tr><td>–restart always</td><td>容器随docker启动而自动启动</td></tr><tr><td>-e TZ&#x3D;’Asia&#x2F;Shanghai’</td><td>设置时区</td></tr><tr><td>-e POSTGRES_PASSWORD&#x3D;’1234qwer</td><td>设置密码为1234qwer</td></tr><tr><td>-e ALLOW_IP_RANGE&#x3D;0.0.0.0&#x2F;0</td><td>允许远程访问</td></tr><tr><td>-v pgdata:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data -p 55435:5432 -d postgres</td><td>挂载数据目录到<strong>卷：pgdata</strong>（也就是我们第一步创建的数据卷）</td></tr><tr><td>-p 55435:5432</td><td>设置端口映射。55435（宿主机端口）:5432（容器端口）</td></tr></tbody></table></li><li><p>连接测试数据库<br>  本节将使用pgadmin进行数据库连接测试<br>4.1 打开<a href="https://www.pgadmin.org/download/pgadmin-4-windows/">官网链接</a>，下载安装<br>4.2 打开Servers-&gt;Register，如下图所示输入各种参数：<br>连接名：<br><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/pgadmin1.png" alt="连接名" title="连接名"><br>输入账号密码，默认账号postgres<br><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/pgadmin2.png" alt="账号密码" title="账号密码"><br>连接成功，则可以看到默认数据库postgres<br><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/pgadmin3.png" alt="默认数据库" title="默认数据库"><br>4.3 其他常见的docker run命令<br><strong>ladp:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart always -p 389:389 -p 636:636 --name my_ldap --network bridge --hostname openldap-host --env LDAP_ORGANISATION=&quot;passport&quot; --env LDAP_DOMAIN=&quot;passport.com&quot; --env LDAP_ADMIN_PASSWORD=&quot;1234qwer&quot; -v ldapdata:/etc/ldap/slapd.d -v ldapconfig:/var/lib/ldap --detach osixia/openldap</span><br></pre></td></tr></table></figure><p><strong>rabbitmq:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --hostname my-rabbit --name rabbit --restart always -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br></pre></td></tr></table></figure><p><strong>redis:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart=always -p 6379:6379 --name redis -d redis</span><br></pre></td></tr></table></figure><p><strong>zookeeper:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -e TZ=&quot;Asia/Shanghai&quot; -p 2181:2181 -v $PWD/data:/data --name zookeeper --restart always zookeeper</span><br></pre></td></tr></table></figure><p><strong>postgres:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name postgress --restart always -e TZ=&#x27;Asia/Shanghai&#x27; -e POSTGRES_PASSWORD=&#x27;1234qwer&#x27; -e ALLOW_IP_RANGE=0.0.0.0/0 -v pgdata:/var/lib/postgresql/data -p 55435:5432 -d postgres</span><br></pre></td></tr></table></figure><p><strong>nginx:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart always -d -p 80:80 --name my-nginx -v nginx-config:/etc/nginx/conf.d nginx</span><br></pre></td></tr></table></figure><p><strong>sqlserver</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e &quot;ACCEPT_EULA=Y&quot; -e &quot;MSSQL_SA_PASSWORD=Ex@mpleP@ssw0rd!&quot;  -p 1433:1433 --name sqlserver -v mssql_data:/var/opt/mssql  -d mcr.microsoft.com/mssql/server</span><br></pre></td></tr></table></figure><p><strong>nexus3</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart always -d -p 18081:8081 --name nexus -e NEXUS_SECURITY_RANDOMPASSWORD=false -e NEXUS_SECURITY_DEFAULTADMINPASSWORD=admin123 -v nexus_data:/nexus-data sonatype/nexus3</span><br></pre></td></tr></table></figure></li></ol></br><hr></br><ul><li><strong>总结</strong><br>本文讨论如何在windows环境下如何使用docker for windows搭建软件开发的调试环境，主要集中演示了如何安装docker for windows，并运行了postgresql容器。由于范围限定在开发调试环境，因此不设计生产环境的部署，也不推荐将上述配置用于生产。<br>数据卷的使用。如果你希望数据不随容器的关闭移除而消失，则必须使用数据卷挂载，请根据实际情况进行取舍</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/08/hello-world/"/>
      <url>/2023/11/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
