<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MetaContext框架的并发解决方案</title>
      <link href="/2024/06/26/MetaContext%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2024/06/26/MetaContext%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h4 id="并发案例"><a href="#并发案例" class="headerlink" title="并发案例"></a>并发案例</h4><h5 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a>场景设计</h5><p>想象这样一个场景，我在数据库中有一个表InventoryItem来管理库存的增加和扣减，该表包含两个字段（为了简单起见，忽略其他字段），如下所示：</p><table><thead><tr><th>字段名</th><th>类型</th><th>名称</th></tr></thead><tbody><tr><td>Id</td><td>varchar</td><td>库存Id</td></tr><tr><td>Quantity</td><td>decimal</td><td>数量</td></tr></tbody></table><p>初始化id&#x3D;’01’的库存为100，此时表的数据呈现为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Quantity&quot;</span><span class="punctuation">:</span> <span class="number">100</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="并发危机"><a href="#并发危机" class="headerlink" title="并发危机"></a>并发危机</h5><ol><li><p>用户User1和用户User2同时获取到这个库存Item：</p></li><li><p>用户user1操作增加库存数量20，此时数据为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">//100+20</span></span><br><span class="line">    <span class="attr">&quot;Quantity&quot;</span><span class="punctuation">:</span> <span class="number">120</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>提交数据更新，执行的sql语句大致如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> InventoryItem <span class="keyword">set</span> Quantity<span class="operator">=</span><span class="number">120</span> <span class="keyword">where</span> Id<span class="operator">=</span><span class="string">&#x27;01&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>用户user2操作减少库存数量30，此时数据为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">//100-30</span></span><br><span class="line">    <span class="attr">&quot;Quantity&quot;</span><span class="punctuation">:</span> <span class="number">70</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>同样提交数据更新，执行的sql语句大致如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> InventoryItem <span class="keyword">set</span> Quantity<span class="operator">=</span><span class="number">70</span> <span class="keyword">where</span> Id<span class="operator">=</span><span class="string">&#x27;01&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>数据最终结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Quantity&quot;</span><span class="punctuation">:</span> <span class="number">70</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这简直太离谱了，<strong>100+20-30&#x3D;90</strong>的结果并未出现，数据仅保留了最后一次更新的结果!<br>这就是较高并发情况下，不处理并发问题的严重后果：<strong>导致应用程序完全无法使用！</strong></p></li></ol><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>MetaContext框架使用efcore实现的仓储，也基于efcore实现的乐观并发控制来解决此类问题。本节内容：先复现问题，再使用框架提供的并发控制内容来解决问题，最后将通过源代码来讲解实现的思路。</p><h5 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h5><ol><li><p>设计InventoryItem聚合根</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InventoryItem</span>(<span class="params"><span class="built_in">string</span> id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">decimal</span> quantity</span>)</span></span><br><span class="line"><span class="function">    : <span class="title">AggregateRoot</span>&lt;<span class="title">string</span>&gt;(<span class="params">id</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InventoryItem</span>(<span class="params"><span class="built_in">string</span> id</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">this</span>(<span class="params">id, <span class="number">0</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Quantity &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; = quantity;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 增加库存</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Plus</span>(<span class="params"><span class="built_in">decimal</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        =&gt; Quantity += <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 扣减库存</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reduce</span>(<span class="params"><span class="built_in">decimal</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        =&gt; Quantity -= <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义Command和CommandHandler</p></li></ol><ul><li><p>PlusCommand：用来增加库存数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">PlusCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PlusCommand</span>(<span class="params"><span class="built_in">string</span> id, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">decimal</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Id = id;</span><br><span class="line">        Value = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Value &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlusCommandHandler</span>(<span class="params">IContext&lt;InventoryItem, <span class="built_in">string</span>&gt; context</span>)</span></span><br><span class="line"><span class="function">    : ICommandHandler&lt;PlusCommand&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Handle</span>(<span class="params">PlusCommand command</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> item = <span class="keyword">await</span> context.Get(command.Id);</span><br><span class="line">        item.Plus(command.Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>ReduceCommand：用来扣减库存数量</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">ReduceCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReduceCommand</span>(<span class="params"><span class="built_in">string</span> id, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">decimal</span> quantity</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Id = id;</span><br><span class="line">        Quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Quantity &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReduceCommandHandler</span>(<span class="params">IContext&lt;InventoryItem, <span class="built_in">string</span>&gt; context</span>)</span></span><br><span class="line"><span class="function">    : ICommandHandler&lt;ReduceCommand&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Handle</span>(<span class="params">ReduceCommand command</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> item = <span class="keyword">await</span> context.Get(command.Id);</span><br><span class="line">        item.Reduce(command.Quantity);</span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>执行测试代码<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> appScope = ApplicationScope.UseAppContext&lt;InventoryAppModule&gt;();</span><br><span class="line"><span class="function">IServiceResolver <span class="title">GetResolver</span>()</span> =&gt; appScope.GetResolver();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> commandExecutor = GetResolver().Resolve&lt;ICommandExecutor&gt;();</span><br><span class="line">NewItemCommand newItemCommand = <span class="keyword">new</span>(Guid.NewGuid().ToString(), <span class="number">100</span>);</span><br><span class="line"><span class="keyword">await</span> commandExecutor.Execute(newItemCommand);</span><br><span class="line"><span class="comment">//模拟并发</span></span><br><span class="line">Task.WaitAll(Task.Run(<span class="keyword">async</span> ()=&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> GetResolver().Resolve&lt;ICommandExecutor&gt;()</span><br><span class="line">    .Execute(<span class="keyword">new</span> PlusCommand(newItemCommand.GoodId, <span class="number">20</span>));</span><br><span class="line">&#125;),</span><br><span class="line">Task.Run(<span class="keyword">async</span> ()=&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> GetResolver().Resolve&lt;ICommandExecutor&gt;()</span><br><span class="line">    .Execute(<span class="keyword">new</span> ReduceCommand(newItemCommand.GoodId, <span class="number">30</span>));</span><br><span class="line">&#125;));</span><br><span class="line"><span class="keyword">var</span> item = <span class="keyword">await</span> GetResolver().Resolve&lt;IContext&lt;InventoryItem, <span class="built_in">string</span>&gt;&gt;().Get(newItemCommand.GoodId);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;库存Id:<span class="subst">&#123;item.Id&#125;</span>，库存数量:<span class="subst">&#123;item.Quantity&#125;</span>&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br><span class="line"></span><br></pre></td></tr></table></figure>上述代码输出为：库存Id:（随机的Guid值），库存数量:70</li></ol><h5 id="解决并发冲突"><a href="#解决并发冲突" class="headerlink" title="解决并发冲突"></a>解决并发冲突</h5><p>如上节所示，我们完美的复现了并发冲突，现在让我们来着手解决问题（见证奇迹的时刻）</p><ol><li>启用并发检查</li></ol><ul><li>在仓储项目的InventoryContext类中新增代码：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">AfterModelCreated</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder.Entity&lt;InventoryItem&gt;()</span><br><span class="line">        <span class="comment">//使用并发检查</span></span><br><span class="line">        .UseConcurrencyCheck();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>执行迁移命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dotnet ef migrations add concurrencyCheck</span><br><span class="line">dotnet ef database update</span><br></pre></td></tr></table></figure></li><li><p>运行测试代码<br>输出：库存Id:（随机的Guid值），库存数量:90<br>并发冲突解决</p></li></ol><h5 id="实现思路和源码讲解"><a href="#实现思路和源码讲解" class="headerlink" title="实现思路和源码讲解"></a>实现思路和源码讲解</h5><p>（未完待续）<br>………</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MetaContext框架的面向切面编程(Aop)</title>
      <link href="/2024/05/17/MetaContext%E6%A1%86%E6%9E%B6%E7%9A%84%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-Aop/"/>
      <url>/2024/05/17/MetaContext%E6%A1%86%E6%9E%B6%E7%9A%84%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-Aop/</url>
      
        <content type="html"><![CDATA[<h4 id="前言概述"><a href="#前言概述" class="headerlink" title="前言概述"></a>前言概述</h4><p>面向切面编程（AOP）是一种编程范式，通过将横切关注点（如日志记录、事务管理、安全性等）从核心业务逻辑中分离出来，增强代码的模块化和可维护性。AOP的核心概念包括切面（Aspect）、切点（Join Point）、通知（Advice）和切入点（Pointcut）。切面是封装横切关注点的模块，切点是程序执行的特定点，通知是定义在切点处执行的动作，切入点是用于匹配切点的表达式。</p><p>MetaContext使用Autofac作为默认的Ioc容器，同时通过封装集成Autofac.Extras.DynamicProxy包来实现Aop。所以MetaContent对于Aop的支持分为两种方式：</p><ul><li>原生的Autofac.Extras.DynamicProxy的功能。具体请参考Autofac.Extras.DynamicProxy的使用方式，本文不做赘述</li><li>MetaContext的Aop特性。这部分融合了MetaContext框架的设计哲学，是本文重点</li></ul><h4 id="设计哲学"><a href="#设计哲学" class="headerlink" title="设计哲学"></a>设计哲学</h4><ul><li><strong>面向接口</strong>。MetaContext框架坚定支持这一设计理念，因此Aop特性也仅支持对于接口的面向切面编程。</li><li><strong>高度自治</strong>。MetaContext框架的切面(Aspect)设计具有非常强大的能力，可以自行决定程序是否继续执行或是终止。</li><li><strong>高扩展性</strong>。MetaContext框架支持任意数量的切面，将按顺序执行切面</li></ul><h4 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a>实践案例</h4><h5 id="工作单元"><a href="#工作单元" class="headerlink" title="工作单元"></a>工作单元</h5><p>本节将讲述MetaContext框架如何利用框架自带Aop功能实现工作单元的自动提交，从而展示MetaContent框架的强大的Aop能力。</p><ul><li><p>工作单元概述<br>工作单元模式（Unit of Work）通过维护一个对象集合记录其状态变化，确保在事务中统一处理数据库操作，避免数据不一致，提高性能和简化错误处理。它将所有变更操作打包成一个单元，在完成后统一提交或回滚。</p></li><li><p>面临问题<br>我见过太多的公司和项目组，将工作单元模型简单实现对于数据库事务操作的简单封装。相应的sdk提供一个简单的操作列表，操作被添加为列表项，然后手动的执行提交，进而实现所谓的工作单元模式。这种过于老土的方式将带来以下麻烦：</p><ol><li>相同的服务需要提供两个方法，提交工作单元和不提交工作单元的版本。因为可能涉及到独立提交和协作提交。</li><li>工作单元这种基础设施代码对业务代码构成侵入性挑战，不利于业务逻辑本身的关注。</li></ol></li><li><p>需求和解决方案<br>对于上述的问题，我们的需求很明显：通过<strong>隐式的工作单元自动提交</strong>来解决这种麻烦。<br>在MetaContext框架中，自动提交工作单元的切点位于应用层的方法执行结束之后（不同版本可能略有差异），下面之具体的Aop切面开发的步骤：</p><ol><li>新增切面类，实现IMetaAspect接口，代码如下</li></ol>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">UnitOfWorkAspect</span>(<span class="params">IUnitOfWorkFactory unitOfWorkFactory</span>) : IMetaAspect</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Stack&lt;<span class="built_in">string</span>&gt; _stack = [];</span><br><span class="line">    <span class="keyword">private</span> IUnitOfWork? _unitOfWork;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Intercept</span>(<span class="params">IInvocation invocation</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _unitOfWork ??= unitOfWorkFactory.OpenUnitOfWork();</span><br><span class="line">        <span class="built_in">string</span> entry = <span class="string">$&quot;<span class="subst">&#123;invocation.Method.ReflectedType?.FullName&#125;</span>.<span class="subst">&#123;invocation.Method.Name&#125;</span>&quot;</span>;</span><br><span class="line">        _stack.Push(entry);</span><br><span class="line">        invocation.Proceed();</span><br><span class="line">        _stack.Pop();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当完成出栈，说明调用栈完成，可以提交</span></span><br><span class="line">        <span class="keyword">if</span> (_stack.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _unitOfWork.Commit();</span><br><span class="line">            _unitOfWork.Dispose();</span><br><span class="line">            _unitOfWork = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>为应用层服务增加切面拦截，在模块类(详见：<a href="">模块系统</a>)中的Load&#x2F;PreLoad方法中，添加切面，代码如下</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">DomainCoreModule</span> : <span class="title">MetaModule</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Load</span>(<span class="params">IContextConfig contextConfig</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//....其他代码</span></span><br><span class="line">        <span class="comment">//增加工作单元切面</span></span><br><span class="line">        contextConfig.AddAspect&lt;UnitOfWorkAspect, IApplicationService&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，我们通过使用MetaContext框架Aop功能，只需简单两步，即可完成Aop的开发</p></li></ul><h5 id="Mock服务"><a href="#Mock服务" class="headerlink" title="Mock服务"></a>Mock服务</h5><p>细心的你一定发现发现了上一个案例当中的这段代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Intercept</span>(<span class="params">IInvocation invocation</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//省略其他代码..</span></span><br><span class="line">            invocation.Proceed();</span><br><span class="line">            </span><br></pre></td></tr></table></figure><p>没错，这段代码控制执行程序继续前进，也就是当前切面可决定是否进入到下一个切面（或最终执行的类）当中，这给了切面极大的权限。下面的例子中，我们将利用该特性实现对于服务的Mock。</p><ol><li><p>新增一个接口，约束为IFabrication类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHelloService</span> : <span class="title">IFabrication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">SayHi</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现IHelloService接口</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">HelloService</span> : <span class="title">IHelloService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">SayHi</span>()</span> =&gt; <span class="string">&quot;你好，世界&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新增拦截切面，实现IMetaAspect接口</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">FakeHelloAspect</span> : <span class="title">IMetaAspect</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Intercept</span>(<span class="params">IInvocation invocation</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (invocation.Method.ReflectedType == <span class="keyword">typeof</span>(IHelloService)</span><br><span class="line">            &amp;&amp; invocation.Method.Name == <span class="keyword">nameof</span>(IHelloService.SayHi))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//直接修改返回值，而且不继续执行</span></span><br><span class="line">            invocation.ReturnValue = <span class="string">&quot;你已被拦截，这是一个虚假的返回值&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            invocation.Proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新增Fake模块</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AppName(<span class="string">&quot;AspectTestsModule&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">AspectTestsModule</span> : <span class="title">AppModule</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Load</span>(<span class="params">IContextConfig contextConfig</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        contextConfig.AddAspect&lt;FakeHelloAspect, IFabrication&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后，我们使用两个单元测试来进行验证</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 使用默认模块</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AspectsTests</span> : <span class="title">AbstractTestUnit</span>&lt;<span class="title">DefaulTestModule</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Fact</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test_SayHi</span>()</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">var</span> helloService = GetService&lt;IHelloService&gt;();</span><br><span class="line">        <span class="keyword">var</span> result = helloService.SayHi();</span><br><span class="line">        Assert.Equal(<span class="string">&quot;你好，世界&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 使用包含了Mock代码的模块</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FakeAspectsTests</span> : <span class="title">AbstractTestUnit</span>&lt;<span class="title">AspectTestsModule</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Fact</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test_SayHi</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> helloService = GetService&lt;IHelloService&gt;();</span><br><span class="line">        <span class="keyword">var</span> result = helloService.SayHi();</span><br><span class="line">        Assert.Equal(<span class="string">&quot;你已被拦截，这是一个虚假的返回值&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>到目前为止，我们成功的实现了对于IHelloService的Mock。对于Mock的使用场景，相信经验丰富的你已经很很多想法了，just do it！去实现它！</p><h4 id="基于特性的Aop"><a href="#基于特性的Aop" class="headerlink" title="基于特性的Aop"></a>基于特性的Aop</h4><p>使用特性(Attribute)实现Aop的方式也很场景，MetaContext框架也支持这样的方式。话不多说，让我们看代码。</p><ol><li><p>新增服务IAopHelloService</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAopHelloService</span> : <span class="title">IFabrication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">Hello</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现IAopHelloService</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">AopHelloService</span> : <span class="title">IAopHelloService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Hello</span>()</span> =&gt; <span class="string">&quot;Hello,World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>新增FakeHelloAttribute，继承自MetaAopAttribute</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">FakeHelloAttribute</span> : <span class="title">MetaAopAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Intercept</span>(<span class="params">IInvocation invocation</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        invocation.ReturnValue = <span class="string">&quot;Fake Hello&quot;</span>;</span><br><span class="line">        <span class="comment">//注释掉继续执行，直接返回结果</span></span><br><span class="line">        <span class="comment">//invocation.Proceed();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用FakeHelloAttribute修饰方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAopHelloService</span> : <span class="title">IFabrication</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">FakeHello</span>]</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">Hello</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>通过单元测试验证结果</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 使用默认模块</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AspectsTests</span> : <span class="title">AbstractTestUnit</span>&lt;<span class="title">DefaulTestModule</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Fact</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test_Hello</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        IAopHelloService aopHelloService = GetService&lt;IAopHelloService&gt;();</span><br><span class="line">        <span class="keyword">var</span> result = aopHelloService.Hello();</span><br><span class="line">        Assert.Equal(<span class="string">&quot;Fake Hello&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>从本例中，我们可以得出结论，使用特性的方式进行Aop编程似乎更为简单，但凡事都有代价，在满足以下条件的情况，你可以考虑特性Aop的方式：</p><ul><li>拥有对于接口层代码的修改权限</li><li>接受一定的代码入侵性</li><li>切面的目标没有普遍性，以特例居多</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>MetaContext框架基于Castle.DynamicProxy封装了两种Aop方式：</p><ul><li>切面模式，为已注册的服务添加切面，使用较为全局的Aop</li><li>特性模型。适用于特例的Aop，实现低入侵性的功能扩展</li></ul><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ol><li><p>继承自MetaAopAttribute的Aop特性，可以用在任何借口上吗？<br>答：并不是。只有框架自动注册的服务会支持Aop特性，参考下表：</p><table><thead><tr><th>服务类型</th><th>描述</th><th>是否支持Aop特性</th></tr></thead><tbody><tr><td>IApplicationService</td><td>应用服务</td><td>支持</td></tr><tr><td>IDomainService</td><td>领域服务</td><td>支持</td></tr><tr><td>IFabrication</td><td>纯虚构（无意义主要作为自动注册的约束）</td><td>支持</td></tr></tbody></table></li><li><p>Aop切面的执行顺序是什么样的？<br>答：实现IMetaAspect的切面，按添加顺序的倒序执行，即后添加的先执行；继承自MetaAopAttribute的Aop特性按代码的位置执行</p></li><li><p>MetaContext框架支持自定义的Aop吗？<br>答：当然支持。MetaContext框架兼容Castle.DynamicProxy提供的动态代理功能</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于用例驱动开发的AI Agent思路</title>
      <link href="/2024/05/11/%E5%9F%BA%E4%BA%8E%E7%94%A8%E4%BE%8B%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%9A%84AI-Agent%E6%80%9D%E8%B7%AF/"/>
      <url>/2024/05/11/%E5%9F%BA%E4%BA%8E%E7%94%A8%E4%BE%8B%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%9A%84AI-Agent%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>随着软件开发的复杂性不断增加，如何快速而准确地将需求转化为可执行代码成为了开发过程中的重要挑战。传统的方法往往需要开发人员阅读理解用例文档，并编写相应的代码，这种人脑的转换方式完全取决于程序猿的个人能力。为了解决这一问题，我们提出了利用AI Agent实现用例文档驱动的代码生成的方法。</p><ol><li><p><strong>使用大型语言模型读取用例文档</strong><br> 我们使用大型语言模型（如GPT）来读取用例文档，这些文档包含了用户需求、系统功能等信息。尽管大型语言模型能够很好地理解自然语言文本，但在读取用例文档时可能面临一些困难。这包括文档的多样性、专业术语和缩写词的理解、上下文的把握以及歧义性。为了提高模型的准确性和鲁棒性，可以采用预处理技术、模型微调和结合规则引擎等方法。</p></li><li><p><strong>解析文档中的系统事件</strong><br> 从文档中解析出系统事件，这些事件可以是用户行为、系统状态变化等。为了更好地处理文档的多样性和复杂性，我们采用了专门设计的模板文档，并利用AI进行文档检查，以确保文档的质量和一致性。</p></li><li><p><strong>转换系统事件为DSL语言</strong><br> 将解析出的系统事件转换为特定的DSL（Domain-Specific Language）语言。为了解决DSL语言的设计和生成问题，我们使用了成熟的框架，并针对性地增加了对DSL语言的适配。这样一来，我们可以更轻松地设计出符合需求的DSL语言，并将系统事件转换为DSL语言的表达形式。为了使得DSL语言更加精准，我们会使用微调模型进行系统事件解析。</p></li><li><p><strong>生成代码</strong><br> 利用DSL语言生成最终的编程语言代码。为了解决代码生成的难点，我们使用了微调模型进行系统事件解析，以提高解析的准确性和效率。同时，我们还支持生成单元测试和API自动化测试，以确保生成的代码质量和可靠性。</p></li><li><p><strong>生成单元测试和自动化测试项目</strong><br>根据生成的代码，自动生成相应的单元测试和API自动化测试项目，以验证生成代码的正确性和可靠性。这一步可以通过模板和自动化脚本实现，减少手动工作量，提高测试覆盖率和代码质量。</p></li></ol><p>综上所述，利用AI Agent实现用例文档驱动的C#代码生成可以极大地提高开发效率和代码质量，减少人为错误，促进团队沟通和协作。这一方法不仅可以应用于软件开发领域，也可以推广到其他领域，为自动化代码生成提供新的思路和方法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用MetaContext框架创建项目</title>
      <link href="/2024/04/23/%E4%BD%BF%E7%94%A8MetaContext%E6%A1%86%E6%9E%B6%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
      <url>/2024/04/23/%E4%BD%BF%E7%94%A8MetaContext%E6%A1%86%E6%9E%B6%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MetaContext工具命令</title>
      <link href="/2024/04/20/MetaContext%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/04/20/MetaContext%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>MetaContext框架提供丰富的工具链，通过安装工具可以简化项目的开发</p><h4 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h4><ul><li><p>安装全局工具</p><figure class="highlight plaintext"><figcaption><span>CLI</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet tool install --global MetaContext.Tool</span><br></pre></td></tr></table></figure></li><li><p>更新全局工具</p><figure class="highlight plaintext"><figcaption><span>CLI</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet tool update --global MetaContext.Tool</span><br></pre></td></tr></table></figure></li><li><p>查看全局工具列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet tool list -g</span><br></pre></td></tr></table></figure></li></ul><h4 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h4><table><thead><tr><th>命令</th><th>描述</th><th>参数说明</th></tr></thead><tbody><tr><td>metaexec errtextgenerate</td><td>生成错误码资源文件</td><td>无参数</td></tr><tr><td>metaexec repoinit</td><td>初始化仓储项目</td><td><li>pgsql。生成应用postgresql数据库的仓储</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MetaContext框架设想</title>
      <link href="/2024/04/19/MetaContext%E6%A1%86%E6%9E%B6%E8%AE%BE%E6%83%B3/"/>
      <url>/2024/04/19/MetaContext%E6%A1%86%E6%9E%B6%E8%AE%BE%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h4 id="修订历史"><a href="#修订历史" class="headerlink" title="修订历史"></a>修订历史</h4><table><thead><tr><th>版本</th><th>日期</th><th>描述</th><th>作者</th></tr></thead><tbody><tr><td>初始V1</td><td>2024-04-19</td><td>整理、建立设想文档，作为MetaContext框架的备忘</td><td>荆蛮</td></tr><tr><td>…….</td><td></td><td></td><td></td></tr></tbody></table><p><br><br></p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>框架最终的名称确定为MetaContext，中文名为<strong>元上下文</strong>或<strong>超上下文</strong>。这个命名来源于<strong>领域驱动设计（以下简称DDD）</strong>中的BoundContext的概念，这就意味着该框架将极为重视DDD中的战略设计。而在最终的实现当中，Context也将作为设计与编码的共享的一个内核概念，从而有别其他的框架。</p><p>简而言之，MetaContext框架将战略建模和战术建模放在同等重要位置，从而实现对于领域驱动设计的落地，以及对于开发人员的引导</p><br><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><ol><li><p><strong>设计初心</strong><br>关于框架的构想最早可以追溯到很多年前第一次接触领域驱动设计的概念，当时的感觉像打开了一扇窗，在沉醉于DDD各种模式的同时，也彻底改变了我对于软件系统的设计思路。当时就在想，有没有可能设计一套框架，将一些基本的模式固定下来，作为基础的开发。在那之后，在经过多年开发（编码搬砖）的洗礼、学习、反思和尝试（写过不少半成品框架），终于觉得是时候重写一套框架了，用以回应我内心的需求和记录这些年的尝试心得。</p></li><li><p><strong>问题综述</strong><br>我考察过各类框架，包括ABP，基本上认为他们存在以下几个问题：</p><ul><li>试图满足所有开发人员的需求（不是所有开发人员都能熟练掌握领域驱动设计）。比如ABP，号称是部分实现领域驱动设计的模式，但基本上可以甩开领域驱动设计的约束，这就与我需求不符了。</li><li>ORM+框架。大部分的框架做成了ORM+，也就是仅仅在领域驱动设计当中的仓储问题，这就偏离核心了，仓储是挺无关紧要的部分（我也好奇国内的开发者为什么老盯着ORM不放）</li></ul><p>综上所述，我没有发现符合我需求的框架，同时为了避免方向的偏离，所以我决定开发新的框架。</p></li><li><p><strong>框架定位综述</strong><br>MetaContext框架的定位就是协助落地DDD的战略建模和战术建模。因此对于框架的设计要求是提供DDD所需的元模式，以及尽可能的提供非业务相关的基础服务的需求。</p><ul><li>元模式。包括上下文、聚合根、实体、值对象、领域服务、领域事件、仓储等DDD当中的元模式。</li><li>基础服务。开发工具包，可以执行基础代码的生成，比如映射数据库</li></ul></li></ol><br><h4 id="涉众描述"><a href="#涉众描述" class="headerlink" title="涉众描述"></a>涉众描述</h4><ol><li><p><strong>涉众（非用户）概要</strong></p><ul><li>CTO或CIO或企业架构师。他们关心业务代码可复用性、部署的灵活性、以及能否引导编写高质量的代码，从而提高开发水平。同时关心安全性和是否支持高并发。</li></ul></li><li><p><strong>用户概要</strong><br>目标的框架用户大致分为：</p><ul><li>熟悉DDD的高阶开发人员。比如高级工程师或架构师，对于与这类人群，框架的作用主要是支持，提供可用的元模式和基础服务。</li><li>DDD学习者。这类人群指的是对于DDD不甚了了，但很有兴趣学习的开发人员。因此框架的作用是引导和约束。</li></ul></li><li><p><strong>涉众的关键高阶目标及问题</strong></p></li></ol><table><thead><tr><th><div style="width: 100pt">高阶目标</div></th><th>优先级</th><th>相关问题</th><th>当前解决方案</th></tr></thead><tbody><tr><td><div style="width: 100pt">隐式工作单元</div></td><td><div style="width: 40pt">高</div></td><td>对于工作单元，大部分人的理解都只是批量操作，因此常见的设计方式就是一个List记录显式的记录所有操作，然后显式的批量提交，这其实是一个相当糟糕的设计，因为这会使得开发过程当中过度关注一些非业务因素，从而影响设计</td><td>框架将采用隐式的工作单元，进行自动提交，从代码层面来看，近需要操作仓储层接口；当然，也提供手动显式的使用工作单元</td></tr><tr><td>规避网状的模型设计</td><td>高</td><td>按常见的E-R图方式来设计的实体模型，很容易出现网状结构，导致缺乏重点</td><td>框架将自动检测聚合、实体、值对象的依赖关系，规避出现网状模型的可能</td></tr><tr><td>上下文可合并部署和独立部署</td><td>高</td><td>处于对于灵活部署的需求，对于每一个业务上下文都需要支持可以独立部署以及和其他上下文合并部署，充分表现业务的可复用性</td><td>框架通过应用层动态代理的方式，支持本地调用和远程调用，上下文与下文之间通过应用层接口进行交互，从而实现高度解耦，进而支持灵活部署的需求</td></tr><tr><td>模块化</td><td>高</td><td>通过模块化可以分解开发的关注点，模块应该是自治的，并作为项目的最小单元存在</td><td>框架参考ABP的模块化设计，引导模块化开发</td></tr><tr><td>…</td><td></td><td></td><td></td></tr></tbody></table><br><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><ol><li><p><strong>框架展望</strong></p><ul><li>作为系统开发基础框架和服务支撑。</li><li>提供DSL整合进大模型应用开发的工作流当中</li></ul></li><li><p><strong>优点概述</strong></p><ul><li>彻底的、坚定的落地<strong>领域驱动设计</strong></li><li>框架提供超强的扩展性，支持后续的升级和自定义扩展</li><li>计划开发DSL，作为其他工作流的入口</li></ul></li></ol><h4 id="其他需求和约束"><a href="#其他需求和约束" class="headerlink" title="其他需求和约束"></a>其他需求和约束</h4><ol><li>框架的语言。框架的开发语言限制为c#，支持.net6以后的版本</li><li>对于需求的决策。一切不符合领域驱动设计的需求将会被拒绝。、</li><li>基础的依赖。框架将选择Autofac组件作为最基础的Ioc容器依赖，同时也支持ServiceCollection服务注册。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于大模型应用的一些思考</title>
      <link href="/2024/03/29/%E5%9F%BA%E4%BA%8E%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
      <url>/2024/03/29/%E5%9F%BA%E4%BA%8E%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h4 id="前言简介"><a href="#前言简介" class="headerlink" title="前言简介"></a>前言简介</h4><p>到目前为止（2024年3月29日），从媒体的消息来看，关注的焦点还是集中于大模型本身。比如，Anthropic推出来的Claude 3，谷歌推出Gemini，Meta推出免费的Llama 2等等大模型。也就是大模型本身激战正酣，巨头争相竞技。至于为什么，我觉得就是大模型几乎肉眼可见的潜力（在继VR、MR、区块链、元宇宙等概念之后，终于出现一个够得着的科技概念）。<br>我们来看一张大模型应用的架构图：</p><p><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/think_in_llm/llm-reference-arch.png" alt="大模型应用架构图"></p><p>从上图，我们不难看出，大模型的提供的能力是灵魂所在，是核心的驱动力。从AI应用产业角度来说，大模型是绝对的上游，而且这种联系，将前所未有的紧密，也就是离了大模型，就没有大模型应用（好像是句废话），这就是巨头争相竞技的原因。</p><p>但现在，让我们先把这种神仙打架的事情先放一放，集中精力大模型应用，思考如何释放大模型的洪荒之力。</p><p><strong>（未完待续）</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Postgresql和Sqlserver开启两阶段事务</title>
      <link href="/2023/11/29/Postgresql%E5%92%8CSqlserver%E5%BC%80%E5%90%AF%E4%B8%A4%E9%98%B6%E6%AE%B5%E4%BA%8B%E5%8A%A1/"/>
      <url>/2023/11/29/Postgresql%E5%92%8CSqlserver%E5%BC%80%E5%90%AF%E4%B8%A4%E9%98%B6%E6%AE%B5%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="postgresql配置"><a href="#postgresql配置" class="headerlink" title="postgresql配置"></a>postgresql配置</h3><p>postgresql通过启用max_prepared_transactions来支持两阶段事务</p><ol><li><p><strong>找到postgresql.conf文件</strong><br>  不同环境的postgresql数据库目录结构不尽相同，但关键是找到postgresql.conf，以下是常用的方式。</p><ul><li>使用命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find / -name postgresql.conf</span><br></pre></td></tr></table></figure></li><li>直接访问目录（找到data目录）<br>常见的目录：postgresql&#x2F;{版本号}&#x2F;data，如:postgresql&#x2F;16&#x2F;data，表示postgresql16的data目录</li></ul></li><li><p><strong>启用参数max_prepared_transactions</strong><br>  在上一步找到的postgresql.conf文件找到max_prepared_transactions，并修改为max_prepared_transactions&#x3D;100。<br><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/prepared_transactions/preparedtransactions/pgsql1.png" alt="prepared_transactions配置"></p><ul><li>上述配置表示最多允许100个预备事务，具体数量请根据实际情况酌情更改</li><li>如果没有max_prepared_transactions参数，可自行添加</li></ul></li><li><p><strong>重启postgresql数据库</strong></p></li></ol><h3 id="sqlserver配置"><a href="#sqlserver配置" class="headerlink" title="sqlserver配置"></a>sqlserver配置</h3><p>sqlserver的两个阶段事务启用较为繁琐，需要在相关的服务器确保msdtc服务的开启，包括<strong>未部署数据库的iis宿主服务器或其他客户端服务器</strong></p><ol><li><p><strong>启动msdtc服务</strong><br>  <img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/prepared_transactions/preparedtransactions/sqlserver1.png" alt="msdtc服务"></p></li><li><p><strong>配置本地DTC</strong><br>  控制面板-&gt;管理工具-&gt;组件服务-&gt;计算机-&gt;我的电脑-&gt;本地DTC，使用下列配置<br>  <img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/prepared_transactions/preparedtransactions/sqlserver2.png" alt="本地dtc配置1"><br>  <img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/prepared_transactions/preparedtransactions/sqlserver3.png" alt="本地dtc配置2"></p></li><li><p><strong>数据库实例的msdts配置(可选配置，实测中未开启也能成功)</strong><br>  如图所示，sqlserver实例-&gt;属性-&gt;连接，勾选：<strong>需要将分布式事务用于服务器到服务器的通信(E)</strong><br>  <img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/prepared_transactions/preparedtransactions/sqlserver4.png" alt="sqlserver实例配置"></p></li><li><p><strong>注意事项</strong></p><ul><li>一般情况下，修改配置可以立即生效，未生效则应尝试重启数据库或服务器</li><li>需要确保msdtc端口可用，下面是建议的windows防火墙的配置<br> <img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/prepared_transactions/preparedtransactions/sqlserver5.png" alt="windows防火墙配置"></li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Postgresql数据库中分区表和表继承的区别</title>
      <link href="/2023/11/29/Postgresql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%88%86%E5%8C%BA%E8%A1%A8%E5%92%8C%E8%A1%A8%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/11/29/Postgresql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%88%86%E5%8C%BA%E8%A1%A8%E5%92%8C%E8%A1%A8%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h4><p>在Postgresql中，经常使用分区表和表继承来处理分表的的场景，而其对应的数据组织和管理策略则不尽相同，本文主要对比分区表和表继承在分表场景的异同</p><h4 id="具体对比"><a href="#具体对比" class="headerlink" title="具体对比"></a>具体对比</h4><table><thead><tr><th>对比类型</th><th>分区表</th><th>表继承</th></tr></thead><tbody><tr><td>数据操作-写入</td><td>根据分区规则自动路由</td><td>需要创建insert触发器，依赖触发器来完成数据路由</td></tr><tr><td>数据操作-更新</td><td>只需操作主表</td><td>只需操作主表</td></tr><tr><td>数据操作-删除</td><td>只需操作主表</td><td>只需操作主表</td></tr><tr><td>查询对象</td><td>针对主表查询即可</td><td>针对主表查询即可</td></tr><tr><td>查询性能</td><td>分区表有明确的分区条件，在查询的时候仅扫描相关分区，从而提升性能</td><td>不会划分物理分区，所有数据都保存在各个表当中</td></tr><tr><td>表结构管理-新建子表</td><td>手动创建</td><td>手动创建</td></tr><tr><td>表结构管理-主键</td><td>主表的主键默认为全局主键，自动作用于分区表</td><td>需要各自管理主键</td></tr><tr><td>表结构管理-索引</td><td>主表通过建立全局索引（默认），可作用于所有分区表（也可以在分区表上建立局部索引）</td><td>需要各自管理索引</td></tr><tr><td>表结构管理-字段</td><td>主表和子表字段必须完全一致</td><td>子表和主表的字段可以不一致</td></tr><tr><td>表结构管理-唯一约束</td><td>唯一约束（如主键）需包含分区键</td><td>无要求（未确认）</td></tr><tr><td>表结构管理-分区规则</td><td><li>范围分区<li>列表分区<li>哈希分区<li>自定义分区</td><td>无明确的分区规则，需自行处理</td></tr><tr><td>数据管理-备份</td><td>可单独备份分区表</td><td>可单独备份子表</td></tr><tr><td>数据管理-删除子表</td><td>drop对应分区表即可，可以非常快的移除百万级的数据</td><td>通过解除子表的关系可达到移除子表的效果</td></tr></tbody></table><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>从上述的对比中，我们不难发现，分区表适合进行水平分表。而表继承的设计较为灵活，更适合应对模型当中的集成结构，适合垂直分表</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows下使用docker进行开发调试环境准备</title>
      <link href="/2023/11/09/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8docker%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"/>
      <url>/2023/11/09/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8docker%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p>现在的软件项目开发调试日趋复杂，经常需要一堆的软件环境才能正常的进行开发调试。比如数据库、redis、mq等等，这些软件安装麻烦还不好管理，平时不用还占着资源。有没有一种办法解决这个问题呢？答案是有的，我们可以借助docker来完成软件环境的准备，本文将在windows10&#x2F;11的环境下演示使用docker进行开发调试环境准备。</p><ul><li><strong>WSL2环境准备</strong><br>本文只推荐使用基于window for linux的docker安装，原因此处不便展开，具体请百度</li></ul><ol><li><p>打开系统虚拟机平台和WSL(适用于Linux的window子系统)。<br>控制面板-&gt;程序-&gt;启用或关闭Windows功能-&gt;向下滑 勾选以下两项功能。<br><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/winfeatures.png" alt="winfeatures" title="windows功能"></p></li><li><p>下载支持Linux的内核wsl2<br>点击<a href="https://docs.microsoft.com/zh-cn/windows/wsl/wsl2-kernel">官网链接</a>，下载最新版本的更新包，双击运行安装即可。这时你的wsl就为wsl2了</p></li><li><p>设置Wsl默认版本<br>打开Powershell，输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set -default -version 2</span><br></pre></td></tr></table></figure><p>如果仅需要安装docker for windows，那对于wsl2的安装就到此为止了，并不需要安装发行版</p></li></ol></br><hr></br><ul><li><strong>Docker for Windows的安装</strong></li></ul><ol><li><p>下载docker for windows<br>点击<a href="https://www.docker.com/products/docker-desktop/">官网链接</a>，选择docker for windows下载安装</p></li><li><p>设置并启动docker<br>2.1 打开设置setting-&gt;General<br><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/dockersetting.png" alt="dockersetting" title="打开Docker设置"><br>2.2 勾选:Use the wsl2 based engine，并点击Apply &amp; restart<br><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/usewsl2.png" alt="usewsl2" title="使用Wsl2引擎"></p></li><li><p>设置国内镜像加速<br>由于各种原因，默认的镜像地址经常出现缓慢和不稳定，为了我们顺利的使用docker，需要设置国内镜像加速。<br>3.1 打开settings-&gt;Docker Engine<br><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/dockerengine.png" alt="dockerengine" title="Docker引擎"><br>3.2 设置registry-mirrors</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;builder&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;gc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;defaultKeepStorage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20GB&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;experimental&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;https://自己生成.mirror.aliyuncs.com&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>国内常用的镜像加速地址：</strong></p><table><thead><tr><th>镜像提供商</th><th>地址url</th></tr></thead><tbody><tr><td>Docker中国区官方镜像</td><td><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></td></tr><tr><td>网易</td><td><a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></td></tr><tr><td>阿里云（需要自己生成）</td><td>登录：cr.console.aliyun.com</td></tr></tbody></table></li></ol></br><hr></br><ul><li><strong>安装启动postresql数据库</strong><blockquote><p>本节内容将完成postgresql的镜像启动，并将涉及docker的一个重要概念：数据卷的运用<br>数据卷的定义：Docker数据卷是一个可以在Docker容器和主机之间共享数据的特殊目录。它允许容器在不影响主机文件系统的情况下访问主机上的文件，并且可以在多个容器之间共享数据。使用数据卷可以方便地将数据持久化保存，并且在容器删除后仍然保留数据。数据卷是Docker中非常方便的功能，可以帮助用户更好地管理和维护容器化应用程序。<br>简略版：你如果不想<strong>数据随着容器的删除而消失</strong>，就必须独立于容器之外的数据卷<br>综上所述：对于启用postgresql容器，使用数据卷挂载是非常必要的</p></blockquote></li></ul><ol><li><p>创建数据卷<br>1.1 使用下面的命令创建名为pgdata的数据卷</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">volume</span><span class="language-bash"> create pgdata</span></span><br></pre></td></tr></table></figure><p>1.2 查看数据卷，输入命令：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">volume</span><span class="language-bash"> list</span></span><br></pre></td></tr></table></figure><p><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/volume-list.png" alt="dockervolumes" title="查看数据卷"></p></li><li><p>获取Docker镜像<br>2.1 查询目标镜像，输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search postgres</span><br></pre></td></tr></table></figure><p><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/searchimages.png" alt="searchimages" title="查询目标镜像"><br>2.2 拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull postgres</span><br></pre></td></tr></table></figure><p><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/docker-images.png" alt="docker-images" title="本地镜像"></p></li><li><p>使用docker run 命令启动容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name postgress --restart always -e TZ=&#x27;Asia/Shanghai&#x27; -e POSTGRES_PASSWORD=&#x27;1234qwer&#x27; -e ALLOW_IP_RANGE=0.0.0.0/0 -v pgdata:/var/lib/postgresql/data -p 55435:5432 -d postgres</span><br></pre></td></tr></table></figure><p>查看已启动容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><strong>命令详解</strong></p><table><thead><tr><th>命令名称</th><th>解释及描述</th></tr></thead><tbody><tr><td>–name</td><td>容器名称</td></tr><tr><td>–restart always</td><td>容器随docker启动而自动启动</td></tr><tr><td>-e TZ&#x3D;’Asia&#x2F;Shanghai’</td><td>设置时区</td></tr><tr><td>-e POSTGRES_PASSWORD&#x3D;’1234qwer</td><td>设置密码为1234qwer</td></tr><tr><td>-e ALLOW_IP_RANGE&#x3D;0.0.0.0&#x2F;0</td><td>允许远程访问</td></tr><tr><td>-v pgdata:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data -p 55435:5432 -d postgres</td><td>挂载数据目录到<strong>卷：pgdata</strong>（也就是我们第一步创建的数据卷）</td></tr><tr><td>-p 55435:5432</td><td>设置端口映射。55435（宿主机端口）:5432（容器端口）</td></tr></tbody></table></li><li><p>连接测试数据库<br>  本节将使用pgadmin进行数据库连接测试<br>4.1 打开<a href="https://www.pgadmin.org/download/pgadmin-4-windows/">官网链接</a>，下载安装<br>4.2 打开Servers-&gt;Register，如下图所示输入各种参数：<br>连接名：<br><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/pgadmin1.png" alt="连接名" title="连接名"><br>输入账号密码，默认账号postgres<br><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/pgadmin2.png" alt="账号密码" title="账号密码"><br>连接成功，则可以看到默认数据库postgres<br><img src="https://chenglin-oss.oss-cn-shenzhen.aliyuncs.com/articles/pgadmin3.png" alt="默认数据库" title="默认数据库"><br>4.3 其他常见的docker run命令<br><strong>ladp:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart always -p 389:389 -p 636:636 --name my_ldap --network bridge --hostname openldap-host --env LDAP_ORGANISATION=&quot;passport&quot; --env LDAP_DOMAIN=&quot;passport.com&quot; --env LDAP_ADMIN_PASSWORD=&quot;1234qwer&quot; -v ldapdata:/etc/ldap/slapd.d -v ldapconfig:/var/lib/ldap --detach osixia/openldap</span><br></pre></td></tr></table></figure><p><strong>rabbitmq:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --hostname my-rabbit --name rabbit --restart always -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br></pre></td></tr></table></figure><p><strong>redis:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart=always -p 6379:6379 --name redis -d redis</span><br></pre></td></tr></table></figure><p><strong>zookeeper:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -e TZ=&quot;Asia/Shanghai&quot; -p 2181:2181 -v $PWD/data:/data --name zookeeper --restart always zookeeper</span><br></pre></td></tr></table></figure><p><strong>postgres:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name postgress --restart always -e TZ=&#x27;Asia/Shanghai&#x27; -e POSTGRES_PASSWORD=&#x27;1234qwer&#x27; -e ALLOW_IP_RANGE=0.0.0.0/0 -v pgdata:/var/lib/postgresql/data -p 55435:5432 -d postgres</span><br></pre></td></tr></table></figure><p><strong>nginx:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart always -d -p 80:80 --name my-nginx -v nginx-config:/etc/nginx/conf.d nginx</span><br></pre></td></tr></table></figure><p><strong>sqlserver</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e &quot;ACCEPT_EULA=Y&quot; -e &quot;MSSQL_SA_PASSWORD=Ex@mpleP@ssw0rd!&quot;  -p 1433:1433 --name sqlserver -v mssql_data:/var/opt/mssql  -d mcr.microsoft.com/mssql/server</span><br></pre></td></tr></table></figure><p><strong>nexus3</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart always -d -p 18081:8081 --name nexus -e NEXUS_SECURITY_RANDOMPASSWORD=false -e NEXUS_SECURITY_DEFAULTADMINPASSWORD=admin123 -v nexus_data:/nexus-data sonatype/nexus3</span><br></pre></td></tr></table></figure><p><strong>minio</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9000:9000 -p 9090:9090 --name minio -d --restart=always -e &quot;MINIO_ACCESS_KEY=admin&quot; -e &quot;MINIO_SECRET_KEY=admin123456&quot; -v minio_data:/data -v minio_config:/root/.minio minio/minio server /data --console-address &quot;:9090&quot;</span><br></pre></td></tr></table></figure></li></ol></br><hr></br><ul><li><strong>总结</strong><br>本文讨论如何在windows环境下如何使用docker for windows搭建软件开发的调试环境，主要集中演示了如何安装docker for windows，并运行了postgresql容器。由于范围限定在开发调试环境，因此不设计生产环境的部署，也不推荐将上述配置用于生产。<br>数据卷的使用。如果你希望数据不随容器的关闭移除而消失，则必须使用数据卷挂载，请根据实际情况进行取舍</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/08/hello-world/"/>
      <url>/2023/11/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
